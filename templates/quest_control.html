<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoboCrew VR Control</title>
    <!-- A-Frame Library -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
        body {
            background-color: #111;
            color: #ccc;
            font-family: sans-serif;
        }

        #overlay {
            position: absolute;
            z-index: 1000;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h2>ðŸ¤– RoboCrew VR</h2>
        <p>Enter VR to see the camera feed and control the robot.</p>
        <p><strong>Left Stick:</strong> Drive | <strong>Right Hand:</strong> Arm | <strong>Right Trigger/Grip:</strong>
            Gripper</p>
    </div>

    <a-scene background="color: #111">
        <a-assets>
            <img id="camera-feed" src="/video_feed" crossorigin="anonymous">
        </a-assets>

        <!-- Video Screen (Curved for immersion) -->
        <a-curvedimage src="#camera-feed" height="3.0" radius="2.5" theta-length="90" position="0 1.6 -2.5"
            rotation="0 135 0" scale="1.5 1.5 1.5">
        </a-curvedimage>

        <!-- Camera Rig -->
        <a-entity id="rig" position="0 0 0">
            <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>

            <!-- Controllers -->
            <!-- Left: Drive -->
            <a-entity id="leftHand" oculus-touch-controls="hand: left" robot-drive-controller></a-entity>
            <!-- Right: Arm -->
            <a-entity id="rightHand" oculus-touch-controls="hand: right" robot-arm-controller></a-entity>
        </a-entity>
    </a-scene>

    <script>
        // --- Robot Control Logic (A-Frame Components) ---

        // Throttle config
        const UPDATE_INTERVAL = 100;

        // 1. Drive Controller (Left Hand)
        AFRAME.registerComponent('robot-drive-controller', {
            init: function () {
                this.lastUpdate = 0;
            },
            tick: function (time, timeDelta) {
                // Get Gamepad
                if (!this.el.components['oculus-touch-controls']) return;
                const controller = this.el.components['oculus-touch-controls'].controller;
                if (!controller || !controller.gamepad) return;

                const gp = controller.gamepad;
                if (!gp.axes) return;

                // Quest: axes[2] = X, axes[3] = Y
                const x = gp.axes[2] || 0;
                const y = gp.axes[3] || 0;

                const now = Date.now();
                if (now - this.lastUpdate > UPDATE_INTERVAL) {
                    let direction = 'stop';
                    const DEADZONE = 0.2;

                    if (y < -DEADZONE) direction = 'forward';
                    else if (y > DEADZONE) direction = 'backward';
                    else if (x < -DEADZONE) direction = 'left';
                    else if (x > DEADZONE) direction = 'right';

                    fetch('/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ direction: direction })
                    }).catch(e => { });

                    this.lastUpdate = now;
                }
            }
        });

        // 2. Arm Controller (Right Hand) - WITH SMOOTHING, SAFETY & RACE CONDITION FIX
        AFRAME.registerComponent('robot-arm-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.gripperState = false;
                this.lastGripperCheck = 0;

                // Flag to ensure we don't start calibration/moving until we have data
                this.dataLoaded = false;

                // Smoothing / Safety State
                this.currentArmState = {
                    shoulder_pan: 0,
                    shoulder_lift: 0,
                    elbow_flex: 0,
                    wrist_roll: 0,
                    wrist_flex: 0
                };

                // Offset calibration (to align VR hand with Robot start pose)
                this.calibrated = false;
                this.offsets = { pan: 0, lift: 0, elbow: 0, roll: 0, flex: 0 };

                // Fetch initial state from robot
                fetch('/arm_position')
                    .then(r => r.json())
                    .then(data => {
                        if (data.positions) {
                            console.log("Initial Robot Arm State:", data.positions);
                            Object.assign(this.currentArmState, data.positions);
                            this.dataLoaded = true; // ENABLE LOOP
                        } else {
                            console.error("No positions in response:", data);
                        }
                    })
                    .catch(e => console.error("Failed to fetch initial arm state:", e));
            },

            tick: function (time, timeDelta) {
                // WAITING FOR DATA (Fixes Race Condition)
                if (!this.dataLoaded) return;

                const now = Date.now();

                // Get Pose
                const position = this.el.object3D.position;
                const rotation = this.el.object3D.rotation; // Euler radians

                // Get Gamepad (Grip Button for Gripper)
                let gripPressed = false;
                if (this.el.components['oculus-touch-controls']) {
                    const controller = this.el.components['oculus-touch-controls'].controller;
                    if (controller && controller.gamepad && controller.gamepad.buttons) {
                        // Button 1 is Grip/Squeeze on Quest
                        gripPressed = controller.gamepad.buttons[1]?.pressed || false;
                    }
                }

                // Check Gripper
                if (gripPressed !== this.gripperState && (now - this.lastGripperCheck > 200)) {
                    this.gripperState = gripPressed;
                    fetch('/gripper', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ closed: gripPressed })
                    }).catch(e => { });
                    this.lastGripperCheck = now;
                }

                if (now - this.lastUpdate > UPDATE_INTERVAL) {

                    // --- Heuristic Kinematics Calculation (INVERTED) ---

                    // Reference Frame:
                    // Origin (0,0,0) is usually user's feet (local-floor).
                    // Shoulder Pivot approximate world pos: (0.2, 1.4, 0)
                    const shoulderAnchor = { x: 0.2, y: 1.3, z: -0.2 };

                    const dx = position.x - shoulderAnchor.x;
                    const dy = position.y - shoulderAnchor.y;

                    // 1. Pan (Inverted: dx * -200)
                    let raw_pan = dx * -200;

                    // 2. Lift (Inverted: dy * -150)
                    let raw_lift = dy * -150;

                    // 3. Elbow (Reach)
                    // Reach = -Z. 0.0 (Close) -> 0.6 (Far)
                    const reach = -position.z;
                    let raw_elbow = (reach - 0.6) * 180;

                    // 4. Wrist Roll (No Negation based on previous fix)
                    let raw_roll = THREE.MathUtils.radToDeg(rotation.z);

                    // 5. Wrist Flex (Inverted: Negated)
                    let raw_flex = -THREE.MathUtils.radToDeg(rotation.x);

                    // --- CALIBRATION (First Frame) ---
                    if (!this.calibrated) {
                        // Calculate offsets so sending (raw + offset) equals current robot state
                        this.offsets.pan = this.currentArmState.shoulder_pan - raw_pan;
                        this.offsets.lift = this.currentArmState.shoulder_lift - raw_lift;
                        this.offsets.elbow = this.currentArmState.elbow_flex - raw_elbow;
                        this.offsets.roll = this.currentArmState.wrist_roll - raw_roll;
                        this.offsets.flex = this.currentArmState.wrist_flex - raw_flex;

                        this.calibrated = true;
                        console.log("Calibrated Offsets:", this.offsets);
                        this.lastUpdate = now;
                        return; // Skip first update to let it settle
                    }

                    // --- Apply Calibration ---
                    let target_pan = raw_pan + this.offsets.pan;
                    let target_lift = raw_lift + this.offsets.lift;
                    let target_elbow = raw_elbow + this.offsets.elbow;
                    let target_roll = raw_roll + this.offsets.roll;
                    let target_flex = raw_flex + this.offsets.flex;

                    // --- Clamping ---
                    target_pan = Math.max(-90, Math.min(90, target_pan));
                    target_lift = Math.max(-90, Math.min(90, target_lift));
                    target_elbow = Math.max(-90, Math.min(0, target_elbow));
                    target_roll = Math.max(-150, Math.min(150, target_roll));
                    target_flex = Math.max(-90, Math.min(90, target_flex));

                    // --- SMOOTHING (LERP) ---
                    // Factor: 0.05 = Very Slow/Smooth
                    const SMOOTH_FACTOR = 0.05;

                    this.currentArmState.shoulder_pan += (target_pan - this.currentArmState.shoulder_pan) * SMOOTH_FACTOR;
                    this.currentArmState.shoulder_lift += (target_lift - this.currentArmState.shoulder_lift) * SMOOTH_FACTOR;
                    this.currentArmState.elbow_flex += (target_elbow - this.currentArmState.elbow_flex) * SMOOTH_FACTOR;
                    this.currentArmState.wrist_roll += (target_roll - this.currentArmState.wrist_roll) * SMOOTH_FACTOR;
                    this.currentArmState.wrist_flex += (target_flex - this.currentArmState.wrist_flex) * SMOOTH_FACTOR;

                    const payload = {
                        positions: {
                            shoulder_pan: this.currentArmState.shoulder_pan,
                            shoulder_lift: this.currentArmState.shoulder_lift,
                            elbow_flex: this.currentArmState.elbow_flex,
                            wrist_roll: this.currentArmState.wrist_roll,
                            wrist_flex: this.currentArmState.wrist_flex
                        }
                    };

                    fetch('/arm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).catch(e => { });

                    this.lastUpdate = now;
                }
            }
        });

        // 3. Texture Auto-Update Fix
        AFRAME.registerComponent('auto-refresh-texture', {
            tick: function () {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material && mesh.material.map) {
                    mesh.material.map.needsUpdate = true;
                }
            }
        });

        // Attach logic to screen
        document.querySelector('a-curvedimage').setAttribute('auto-refresh-texture', '');

    </script>
</body>

</html>