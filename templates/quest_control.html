<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoboCrew VR Control</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
        body {
            background-color: #111;
            color: #ccc;
            font-family: sans-serif;
        }

        #overlay {
            position: absolute;
            z-index: 1000;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h2>ðŸ¤– RoboCrew VR</h2>
        <p><strong>Left Stick:</strong> Drive | <strong>Right Hand:</strong> Arm | <strong>Trigger:</strong> Gripper</p>
    </div>

    <a-scene background="color: transparent" renderer="alpha: true"
        webxr="optionalFeatures: local-floor, hand-tracking">
        <a-assets>
            <img id="camera-feed" src="/video_feed" crossorigin="anonymous">
        </a-assets>

        <a-plane src="#camera-feed" width="2.5" height="1.875" position="0 1.5 -1.8" auto-refresh-texture></a-plane>

        <a-entity id="rig" position="0 0 0">
            <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>
            <a-entity id="leftHand" oculus-touch-controls="hand: left" robot-drive></a-entity>
            <a-entity id="rightHand" oculus-touch-controls="hand: right" robot-arm></a-entity>
        </a-entity>
    </a-scene>

    <script>
        // =============================================
        // CONSTANTS - From example code
        // =============================================
        const UPDATE_INTERVAL = 50; // ~20Hz

        // IK parameters (approximate SO101 arm)
        const ARM_L1 = 0.10; // Link 1 length
        const ARM_L2 = 0.12; // Link 2 length

        // Scaling from example: delta * 220/70 * 0.01
        const X_SCALE = 2.2;   // For shoulder_pan
        const Y_SCALE = 0.7;   // For IK Y (height)
        const Z_SCALE = 0.7;   // For IK X (reach)

        // Angle scaling
        const ANGLE_SCALE = 4.0;

        // Limits
        const DELTA_LIMIT = 0.01;  // Max positional delta per frame
        const ANGLE_LIMIT = 8.0;   // Max angle delta per frame

        // Smoothing
        const SMOOTH_ALPHA = 0.1;

        // =============================================
        // 2-LINK INVERSE KINEMATICS
        // =============================================
        function inverseKinematics(x, y) {
            const dist = Math.sqrt(x * x + y * y);
            const maxReach = ARM_L1 + ARM_L2 - 0.005;
            const minReach = Math.abs(ARM_L1 - ARM_L2) + 0.005;
            const d = Math.max(minReach, Math.min(maxReach, dist));

            // Law of cosines for elbow
            let cosElbow = (ARM_L1 * ARM_L1 + ARM_L2 * ARM_L2 - d * d) / (2 * ARM_L1 * ARM_L2);
            cosElbow = Math.max(-1, Math.min(1, cosElbow));
            const elbowRad = Math.acos(cosElbow);

            // Shoulder angle
            const beta = Math.atan2(y, x);
            let cosAlpha = (ARM_L1 * ARM_L1 + d * d - ARM_L2 * ARM_L2) / (2 * ARM_L1 * d);
            cosAlpha = Math.max(-1, Math.min(1, cosAlpha));
            const alphaRad = Math.acos(cosAlpha);
            const shoulderRad = beta - alphaRad;  // CHANGED: was beta + alphaRad

            // Convert to degrees
            // When arm is horizontal (x>0, y=0): shoulderRad = 0 -> shoulderLift should be 0
            const shoulderLift = THREE.MathUtils.radToDeg(shoulderRad);
            // Elbow: 0 = straight, negative = bent inward
            const elbowFlex = THREE.MathUtils.radToDeg(elbowRad) - 180;

            return [shoulderLift, elbowFlex];
        }

        // =============================================
        // DRIVE CONTROLLER (Left Hand)
        // =============================================
        AFRAME.registerComponent('robot-drive', {
            init: function () {
                this.lastUpdate = 0;
                this.lastState = '';
            },
            tick: function () {
                const ctrl = this.el.components['oculus-touch-controls'];
                if (!ctrl || !ctrl.controller || !ctrl.controller.gamepad) return;

                const gp = ctrl.controller.gamepad;
                if (!gp.axes || gp.axes.length < 4) return;

                const now = Date.now();
                if (now - this.lastUpdate < UPDATE_INTERVAL) return;

                const x = gp.axes[2] || 0;
                const y = gp.axes[3] || 0;
                const DZ = 0.3;

                const state = {
                    forward: y < -DZ,
                    backward: y > DZ,
                    left: x < -DZ,
                    right: x > DZ,
                    slide_left: false,
                    slide_right: false
                };

                const stateStr = JSON.stringify(state);
                if (stateStr !== this.lastState) {
                    fetch('/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: stateStr
                    }).catch(() => { });
                    this.lastState = stateStr;
                }
                this.lastUpdate = now;
            }
        });

        // =============================================
        // ARM CONTROLLER (Right Hand) - Based on example
        // =============================================
        AFRAME.registerComponent('robot-arm', {
            init: function () {
                this.lastUpdate = 0;

                // Previous VR position for delta calculation
                this.prevVrPos = null;
                this.prevWristFlex = null;
                this.prevWristRoll = null;

                // Current robot arm state (in IK space)
                this.currentX = 0.1629;  // From example
                this.currentY = 0.1131;  // From example
                this.pitch = 0;

                // Target joint positions (degrees)
                this.targets = {
                    shoulder_pan: 0,
                    shoulder_lift: 0,
                    elbow_flex: 0,
                    wrist_flex: 0,
                    wrist_roll: 0
                };

                // Gripper state
                this.gripperClosed = false;

                // Listen for trigger events from A-Frame
                this.el.addEventListener('triggerdown', () => {
                    if (!this.gripperClosed) {
                        this.gripperClosed = true;
                        fetch('/gripper', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ closed: true })
                        }).catch(() => { });
                    }
                });

                this.el.addEventListener('triggerup', () => {
                    if (this.gripperClosed) {
                        this.gripperClosed = false;
                        fetch('/gripper', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ closed: false })
                        }).catch(() => { });
                    }
                });
            },

            tick: function () {
                const now = Date.now();
                if (now - this.lastUpdate < UPDATE_INTERVAL) return;

                // Get world position
                const pos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(pos);

                // Get rotation as euler
                const quat = new THREE.Quaternion();
                this.el.object3D.getWorldQuaternion(quat);
                const euler = new THREE.Euler().setFromQuaternion(quat, 'YXZ');

                const wristFlexDeg = THREE.MathUtils.radToDeg(euler.x);
                const wristRollDeg = THREE.MathUtils.radToDeg(euler.z);

                // First frame - initialize previous values
                if (this.prevVrPos === null) {
                    this.prevVrPos = [pos.x, pos.y, pos.z];
                    this.prevWristFlex = wristFlexDeg;
                    this.prevWristRoll = wristRollDeg;
                    this.lastUpdate = now;
                    return;
                }

                // Calculate deltas (as in example)
                const vrDeltaX = (pos.x - this.prevVrPos[0]) * 220;
                const vrDeltaY = (pos.y - this.prevVrPos[1]) * 70;
                const vrDeltaZ = (pos.z - this.prevVrPos[2]) * 70;

                // Update previous
                this.prevVrPos = [pos.x, pos.y, pos.z];

                // Apply pos_scale and limit
                let deltaX = vrDeltaX * 0.01;
                let deltaY = vrDeltaY * 0.01;
                let deltaZ = vrDeltaZ * 0.01;

                deltaX = Math.max(-DELTA_LIMIT, Math.min(DELTA_LIMIT, deltaX));
                deltaY = Math.max(-DELTA_LIMIT, Math.min(DELTA_LIMIT, deltaY));
                deltaZ = Math.max(-DELTA_LIMIT, Math.min(DELTA_LIMIT, deltaZ));

                // Update IK workspace position
                // VR Z forward (negative) -> increase reach
                // VR Y up -> increase height
                this.currentX += deltaZ;  // CHANGED: was -deltaZ. Now: forward = extend
                this.currentY += deltaY;

                // Clamp to workspace
                this.currentX = Math.max(0.05, Math.min(0.25, this.currentX));
                this.currentY = Math.max(-0.10, Math.min(0.20, this.currentY));

                // Handle wrist flex with delta control
                if (this.prevWristFlex !== null) {
                    let deltaPitch = (wristFlexDeg - this.prevWristFlex) * ANGLE_SCALE;
                    deltaPitch = Math.max(-ANGLE_LIMIT, Math.min(ANGLE_LIMIT, deltaPitch));
                    this.pitch += deltaPitch;
                    this.pitch = Math.max(-90, Math.min(90, this.pitch));
                }
                this.prevWristFlex = wristFlexDeg;

                // Handle wrist roll with delta control
                if (this.prevWristRoll !== null) {
                    let deltaRoll = (wristRollDeg - this.prevWristRoll) * ANGLE_SCALE;
                    deltaRoll = Math.max(-ANGLE_LIMIT, Math.min(ANGLE_LIMIT, deltaRoll));
                    this.targets.wrist_roll += deltaRoll;
                    this.targets.wrist_roll = Math.max(-90, Math.min(90, this.targets.wrist_roll));
                }
                this.prevWristRoll = wristRollDeg;

                // Shoulder pan from X movement (delta control)
                if (Math.abs(deltaX) > 0.001) {
                    let deltaPan = deltaX * 200;
                    deltaPan = Math.max(-ANGLE_LIMIT, Math.min(ANGLE_LIMIT, deltaPan));
                    this.targets.shoulder_pan += deltaPan;
                    this.targets.shoulder_pan = Math.max(-180, Math.min(180, this.targets.shoulder_pan));
                }

                // Compute IK for shoulder_lift and elbow_flex
                try {
                    const [ikShoulder, ikElbow] = inverseKinematics(this.currentX, this.currentY);

                    // Smooth transition (from example: alpha = 0.1)
                    this.targets.shoulder_lift = (1 - SMOOTH_ALPHA) * this.targets.shoulder_lift + SMOOTH_ALPHA * ikShoulder;
                    this.targets.elbow_flex = (1 - SMOOTH_ALPHA) * this.targets.elbow_flex + SMOOTH_ALPHA * ikElbow;
                } catch (e) {
                    console.error('IK failed:', e);
                }

                // Compensate wrist_flex to maintain end-effector orientation (from example)
                this.targets.wrist_flex = -this.targets.shoulder_lift - this.targets.elbow_flex + this.pitch;
                this.targets.wrist_flex = Math.max(-90, Math.min(90, this.targets.wrist_flex));

                // Send to robot
                fetch('/arm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ positions: this.targets })
                }).catch(() => { });

                this.lastUpdate = now;
            }
        });

        // =============================================
        // TEXTURE AUTO-REFRESH
        // =============================================
        AFRAME.registerComponent('auto-refresh-texture', {
            tick: function () {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material && mesh.material.map) {
                    mesh.material.map.needsUpdate = true;
                }
            }
        });

    </script>
</body>

</html>