<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoboCrew VR Control</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
        body {
            background-color: #111;
            color: #ccc;
            font-family: sans-serif;
        }

        #overlay {
            position: absolute;
            z-index: 1000;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 14px;
        }

        #debug {
            position: absolute;
            z-index: 1000;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-width: 400px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h2>ðŸ¤– RoboCrew VR</h2>
        <p><strong>Left Stick:</strong> Drive Robot</p>
        <p><strong>Right Hand:</strong> Move Arm</p>
        <p><strong>Right Trigger:</strong> Gripper</p>
    </div>
    <div id="debug">Debug: Waiting for VR...</div>

    <a-scene background="color: transparent" renderer="alpha: true"
        webxr="optionalFeatures: local-floor, hand-tracking">
        <a-assets>
            <img id="camera-feed" src="/video_feed" crossorigin="anonymous">
        </a-assets>

        <a-plane src="#camera-feed" width="2.5" height="1.875" position="0 1.5 -1.8" auto-refresh-texture></a-plane>

        <a-entity id="rig" position="0 0 0">
            <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>
            <a-entity id="leftHand" oculus-touch-controls="hand: left" robot-drive-controller></a-entity>
            <a-entity id="rightHand" oculus-touch-controls="hand: right" robot-arm-controller></a-entity>
        </a-entity>
    </a-scene>

    <script>
        const UPDATE_INTERVAL = 50;
        const debugEl = document.getElementById('debug');

        function debugLog(msg) {
            debugEl.textContent = msg;
            console.log(msg);
        }

        // =============================================
        // 2-LINK INVERSE KINEMATICS
        // =============================================
        const ARM_LINK1 = 0.10;
        const ARM_LINK2 = 0.12;

        function inverseKinematics(x, y) {
            const L1 = ARM_LINK1;
            const L2 = ARM_LINK2;
            const dist = Math.sqrt(x * x + y * y);
            const maxReach = L1 + L2 - 0.01;
            const minReach = Math.abs(L1 - L2) + 0.01;
            const clampedDist = Math.max(minReach, Math.min(maxReach, dist));

            let cosElbow = (L1 * L1 + L2 * L2 - clampedDist * clampedDist) / (2 * L1 * L2);
            cosElbow = Math.max(-1, Math.min(1, cosElbow));
            const elbowAngle = Math.acos(cosElbow);

            const beta = Math.atan2(y, x);
            let cosAlpha = (L1 * L1 + clampedDist * clampedDist - L2 * L2) / (2 * L1 * clampedDist);
            cosAlpha = Math.max(-1, Math.min(1, cosAlpha));
            const alpha = Math.acos(cosAlpha);
            const shoulderAngle = beta + alpha;

            const shoulderLiftDeg = THREE.MathUtils.radToDeg(shoulderAngle) - 90;
            const elbowFlexDeg = -(180 - THREE.MathUtils.radToDeg(elbowAngle));

            return [shoulderLiftDeg, elbowFlexDeg];
        }

        // =============================================
        // DRIVE CONTROLLER (Left Hand)
        // =============================================
        AFRAME.registerComponent('robot-drive-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.lastMovement = null;
            },
            tick: function () {
                if (!this.el.components['oculus-touch-controls']) return;
                const controller = this.el.components['oculus-touch-controls'].controller;
                if (!controller || !controller.gamepad) return;

                const gp = controller.gamepad;
                if (!gp.axes || gp.axes.length < 4) return;

                const x = gp.axes[2] || 0;
                const y = gp.axes[3] || 0;

                const now = Date.now();
                if (now - this.lastUpdate > UPDATE_INTERVAL) {
                    const DEADZONE = 0.3;

                    const movement = {
                        forward: y < -DEADZONE,
                        backward: y > DEADZONE,
                        left: x < -DEADZONE,
                        right: x > DEADZONE,
                        slide_left: false,
                        slide_right: false
                    };

                    const key = JSON.stringify(movement);
                    if (key !== this.lastMovement) {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: key
                        }).catch(e => console.error('Move error:', e));
                        this.lastMovement = key;
                    }

                    this.lastUpdate = now;
                }
            }
        });

        // =============================================
        // ARM CONTROLLER (Right Hand) - DELTA CONTROL
        // =============================================
        AFRAME.registerComponent('robot-arm-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.lastGripperCheck = 0;
                this.gripperClosed = false;

                this.prevPos = null;
                this.prevRot = null;

                this.armState = {
                    shoulder_pan: 0,
                    shoulder_lift: 0,
                    elbow_flex: 0,
                    wrist_flex: 0,
                    wrist_roll: 0
                };

                this.handX = 0.15;
                this.handY = 0.10;
                this.pitch = 0;
            },

            tick: function () {
                const now = Date.now();

                const worldPos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(worldPos);

                const worldQuat = new THREE.Quaternion();
                this.el.object3D.getWorldQuaternion(worldQuat);
                const euler = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');

                // --- GET ALL BUTTONS AND FIND TRIGGER ---
                let triggerValue = 0;
                let allButtons = [];
                if (this.el.components['oculus-touch-controls']) {
                    const controller = this.el.components['oculus-touch-controls'].controller;
                    if (controller && controller.gamepad && controller.gamepad.buttons) {
                        const buttons = controller.gamepad.buttons;
                        allButtons = buttons.map((b, i) => `${i}:${b.value.toFixed(2)}`);

                        // Quest Touch: Button 0 = trigger, Button 1 = grip
                        triggerValue = buttons[0]?.value || 0;
                    }
                }

                // Debug output
                debugLog(`Pos: ${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)} | Trigger: ${triggerValue.toFixed(2)} | Btns: [${allButtons.join(', ')}]`);

                // --- GRIPPER (Trigger button) ---
                const shouldClose = triggerValue > 0.5;
                if (shouldClose !== this.gripperClosed && (now - this.lastGripperCheck > 300)) {
                    this.gripperClosed = shouldClose;
                    console.log(`GRIPPER: Sending closed=${shouldClose}`);
                    fetch('/gripper', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ closed: shouldClose })
                    })
                        .then(r => r.json())
                        .then(data => console.log('Gripper response:', data))
                        .catch(e => console.error('Gripper error:', e));
                    this.lastGripperCheck = now;
                }

                // --- DELTA ARM CONTROL ---
                if (now - this.lastUpdate > UPDATE_INTERVAL) {

                    if (this.prevPos === null) {
                        this.prevPos = worldPos.clone();
                        this.prevRot = euler.clone();
                        this.lastUpdate = now;
                        return;
                    }

                    // Calculate deltas
                    const deltaX = worldPos.x - this.prevPos.x;
                    const deltaY = worldPos.y - this.prevPos.y;
                    const deltaZ = worldPos.z - this.prevPos.z;
                    const deltaRoll = euler.z - this.prevRot.z;
                    const deltaPitch = euler.x - this.prevRot.x;

                    this.prevPos.copy(worldPos);
                    this.prevRot.copy(euler);

                    // Sensitivity - INCREASED
                    const POS_SCALE = 1.0;
                    const PAN_SCALE = 200;      // Shoulder pan sensitivity
                    const ROLL_SCALE = 2.0;     // Wrist roll - INCREASED from 0.3
                    const PITCH_SCALE = 1.0;    // Wrist pitch

                    const MAX_POS_DELTA = 0.03;
                    const MAX_ANGLE_DELTA = 10;

                    const clampedDX = Math.max(-MAX_POS_DELTA, Math.min(MAX_POS_DELTA, deltaX));
                    const clampedDY = Math.max(-MAX_POS_DELTA, Math.min(MAX_POS_DELTA, deltaY));
                    const clampedDZ = Math.max(-MAX_POS_DELTA, Math.min(MAX_POS_DELTA, deltaZ));

                    // --- AXIS MAPPING (INVERTED from before) ---
                    // VR Z forward (negative) -> Robot arm reach forward (positive handX)
                    this.handX += clampedDZ * POS_SCALE;  // INVERTED: was -clampedDZ
                    // VR Y up -> Robot arm height (positive handY)
                    this.handY += -clampedDY * POS_SCALE;  // INVERTED: was clampedDY

                    this.handX = Math.max(0.05, Math.min(0.22, this.handX));
                    this.handY = Math.max(-0.10, Math.min(0.15, this.handY));

                    // Shoulder pan from X movement (INVERTED)
                    const panDelta = -clampedDX * PAN_SCALE;  // INVERTED: was clampedDX
                    this.armState.shoulder_pan += panDelta;
                    this.armState.shoulder_pan = Math.max(-90, Math.min(90, this.armState.shoulder_pan));

                    // IK for shoulder_lift and elbow_flex
                    const [ikShoulder, ikElbow] = inverseKinematics(this.handX, this.handY);

                    const SMOOTH = 0.2;
                    this.armState.shoulder_lift = (1 - SMOOTH) * this.armState.shoulder_lift + SMOOTH * ikShoulder;
                    this.armState.elbow_flex = (1 - SMOOTH) * this.armState.elbow_flex + SMOOTH * ikElbow;

                    // Wrist roll - INCREASED SENSITIVITY
                    const rollDelta = THREE.MathUtils.radToDeg(deltaRoll) * ROLL_SCALE;
                    this.armState.wrist_roll += Math.max(-MAX_ANGLE_DELTA, Math.min(MAX_ANGLE_DELTA, -rollDelta)); // INVERTED
                    this.armState.wrist_roll = Math.max(-150, Math.min(150, this.armState.wrist_roll));

                    // Wrist pitch
                    const pitchDelta = THREE.MathUtils.radToDeg(deltaPitch) * PITCH_SCALE;
                    this.pitch += Math.max(-MAX_ANGLE_DELTA, Math.min(MAX_ANGLE_DELTA, -pitchDelta)); // INVERTED
                    this.pitch = Math.max(-90, Math.min(90, this.pitch));

                    // Wrist compensation
                    this.armState.wrist_flex = -this.armState.shoulder_lift - this.armState.elbow_flex + this.pitch;
                    this.armState.wrist_flex = Math.max(-90, Math.min(90, this.armState.wrist_flex));

                    const payload = {
                        positions: {
                            shoulder_pan: this.armState.shoulder_pan,
                            shoulder_lift: this.armState.shoulder_lift,
                            elbow_flex: this.armState.elbow_flex,
                            wrist_roll: this.armState.wrist_roll,
                            wrist_flex: this.armState.wrist_flex
                        }
                    };

                    fetch('/arm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).catch(e => console.error('Arm error:', e));

                    this.lastUpdate = now;
                }
            }
        });

        // =============================================
        // TEXTURE AUTO-REFRESH
        // =============================================
        AFRAME.registerComponent('auto-refresh-texture', {
            tick: function () {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material && mesh.material.map) {
                    mesh.material.map.needsUpdate = true;
                }
            }
        });

    </script>
</body>

</html>