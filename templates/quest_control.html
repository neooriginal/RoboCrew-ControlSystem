<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoboCrew VR Control</title>
    <!-- A-Frame Library -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
        body {
            background-color: #111;
            color: #ccc;
            font-family: sans-serif;
        }

        #overlay {
            position: absolute;
            z-index: 1000;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }

        #debug-info {
            color: #f0f000;
            font-family: monospace;
            font-size: 0.8em;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h2>ðŸ¤– RoboCrew VR</h2>
        <p><strong>Left Stick:</strong> Drive | <strong>Right Hand:</strong> Arm | <strong>Grip:</strong> Grab</p>
        <div id="debug-info">Waiting for VR...</div>
    </div>

    <a-scene background="color: #111">
        <a-assets>
            <img id="camera-feed" src="/video_feed" crossorigin="anonymous">
        </a-assets>

        <!-- Video Screen (Curved for immersion) -->
        <a-curvedimage src="#camera-feed" height="3.0" radius="2.5" theta-length="90" position="0 1.6 -2.5"
            rotation="0 135 0" scale="1.5 1.5 1.5">
        </a-curvedimage>

        <!-- Camera Rig -->
        <a-entity id="rig" position="0 0 0">
            <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>

            <!-- Controllers -->
            <a-entity id="leftHand" oculus-touch-controls="hand: left" robot-drive-controller></a-entity>
            <a-entity id="rightHand" oculus-touch-controls="hand: right" robot-arm-controller></a-entity>
        </a-entity>
    </a-scene>

    <script>
        const debugEl = document.getElementById('debug-info');
        function log(msg) { debugEl.textContent = msg; }

        const UPDATE_INTERVAL = 100;

        // 1. Drive Controller (Left Hand)
        AFRAME.registerComponent('robot-drive-controller', {
            init: function () {
                this.lastUpdate = 0;
                log("Drive Controller Init");
            },
            tick: function () {
                if (!this.el.components['oculus-touch-controls']) return;
                const controller = this.el.components['oculus-touch-controls'].controller;
                if (!controller || !controller.gamepad) return;

                const gp = controller.gamepad;
                if (!gp.axes) return;

                const x = gp.axes[2] || 0;
                const y = gp.axes[3] || 0;

                const now = Date.now();
                if (now - this.lastUpdate > UPDATE_INTERVAL) {
                    let direction = 'stop';
                    const DEADZONE = 0.2;

                    if (y < -DEADZONE) direction = 'forward';
                    else if (y > DEADZONE) direction = 'backward';
                    else if (x < -DEADZONE) direction = 'left';
                    else if (x > DEADZONE) direction = 'right';

                    // Only send if active? Or heartbeat? existing API expects constant updates?
                    // Let's send.
                    if (direction !== 'stop') {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ direction: direction })
                        }).catch(e => { });
                    }

                    this.lastUpdate = now;
                }
            }
        });

        // 2. Arm Controller (Right Hand)
        AFRAME.registerComponent('robot-arm-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.gripperState = false;
                this.lastGripperCheck = 0;
                log("Arm Controller Init");
            },
            tick: function () {
                if (!this.el.components['oculus-touch-controls']) return;
                const controller = this.el.components['oculus-touch-controls'].controller;
                if (!controller || !controller.gamepad) return;

                // Debug: Show we are tracking
                if (Math.random() < 0.05) log(`Tracking Right Hand...`);

                const now = Date.now();
                const gp = controller.gamepad;

                // 1. Grip Button (Button 1)
                const gripPressed = gp.buttons[1]?.pressed || false;

                if (gripPressed !== this.gripperState && (now - this.lastGripperCheck > 200)) {
                    this.gripperState = gripPressed;
                    fetch('/gripper', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ closed: gripPressed })
                    }).catch(e => { });
                    this.lastGripperCheck = now;
                }

                // 2. Arms (Heuristic IK)
                if (now - this.lastUpdate > UPDATE_INTERVAL) {
                    const position = this.el.object3D.position;
                    const rotation = this.el.object3D.rotation;

                    // Anchor: Shoulder
                    const shoulderAnchor = { x: 0.2, y: 1.3, z: -0.2 };

                    const dx = position.x - shoulderAnchor.x;
                    const dy = position.y - shoulderAnchor.y;

                    // Inverted Mappings
                    let s_pan = Math.max(-90, Math.min(90, dx * -200));
                    let s_lift = Math.max(-90, Math.min(90, dy * -150));

                    // Elbow Reach (Z)
                    // -Z is forward. 
                    const reach = -position.z;
                    // map 0.0 -> -90 (Flexed), 0.6 -> 0 (Straight)
                    let e_flex = (reach - 0.6) * 180;
                    e_flex = Math.max(-90, Math.min(0, e_flex));

                    // Wrist Roll (Z Rotation)
                    let w_roll = THREE.MathUtils.radToDeg(rotation.z);
                    w_roll = Math.max(-150, Math.min(150, w_roll)); // Positive scalar

                    // Wrist Flex (X Rotation) - Inverted
                    let w_flex = THREE.MathUtils.radToDeg(rotation.x);
                    w_flex = Math.max(-90, Math.min(90, -w_flex)); // Inverted

                    const payload = {
                        positions: {
                            shoulder_pan: s_pan,
                            shoulder_lift: s_lift,
                            elbow_flex: e_flex,
                            wrist_roll: w_roll,
                            wrist_flex: w_flex
                        }
                    };

                    fetch('/arm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).catch(e => { });

                    this.lastUpdate = now;
                }
            }
        });

        // Auto-refresh texture component
        AFRAME.registerComponent('auto-refresh-texture', {
            tick: function () {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material && mesh.material.map) {
                    mesh.material.map.needsUpdate = true;
                }
            }
        });
        document.querySelector('a-curvedimage').setAttribute('auto-refresh-texture', '');
    </script>
</body>

</html>