<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoboCrew VR Control</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
        body {
            background-color: #111;
            color: #ccc;
            font-family: sans-serif;
        }

        #overlay {
            position: absolute;
            z-index: 1000;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h2>ðŸ¤– RoboCrew VR</h2>
        <p>Enter <strong>AR/VR</strong> to control.</p>
        <p><strong>Left Stick:</strong> Drive | <strong>Right Hand:</strong> Arm | <strong>Grip:</strong> Gripper</p>
    </div>

    <a-scene background="color: transparent" renderer="alpha: true"
        webxr="optionalFeatures: hit-test, local-floor, hand-tracking">
        <a-assets>
            <img id="camera-feed" src="/video_feed" crossorigin="anonymous">
        </a-assets>

        <!-- Video Screen - Flat plane directly in front -->
        <a-plane src="#camera-feed" width="3.2" height="2.4" position="0 1.5 -2.0" auto-refresh-texture></a-plane>

        <!-- Camera Rig -->
        <a-entity id="rig" position="0 0 0">
            <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>

            <!-- Controllers -->
            <a-entity id="leftHand" oculus-touch-controls="hand: left" robot-drive-controller></a-entity>
            <a-entity id="rightHand" oculus-touch-controls="hand: right" robot-arm-controller></a-entity>
        </a-entity>
    </a-scene>

    <script>
        const UPDATE_INTERVAL = 100;

        // =============================================
        // 1. DRIVE CONTROLLER (Left Hand)
        // =============================================
        AFRAME.registerComponent('robot-drive-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.lastDirection = null;
            },
            tick: function (time, timeDelta) {
                if (!this.el.components['oculus-touch-controls']) return;
                const controller = this.el.components['oculus-touch-controls'].controller;
                if (!controller || !controller.gamepad) return;

                const gp = controller.gamepad;
                if (!gp.axes || gp.axes.length < 4) return;

                // Quest thumbstick: axes[2] = X, axes[3] = Y
                const x = gp.axes[2] || 0;
                const y = gp.axes[3] || 0;

                const now = Date.now();
                if (now - this.lastUpdate > UPDATE_INTERVAL) {
                    const DEADZONE = 0.25;

                    // Build movement object (backend expects boolean flags)
                    const movement = {
                        forward: y < -DEADZONE,
                        backward: y > DEADZONE,
                        left: x < -DEADZONE,
                        right: x > DEADZONE,
                        slide_left: false,
                        slide_right: false
                    };

                    // Only send if something changed
                    const currentDir = JSON.stringify(movement);
                    if (currentDir !== this.lastDirection) {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: currentDir
                        }).catch(e => console.error('Move error:', e));
                        this.lastDirection = currentDir;
                    }

                    this.lastUpdate = now;
                }
            }
        });

        // =============================================
        // 2. ARM CONTROLLER (Right Hand)
        // =============================================
        AFRAME.registerComponent('robot-arm-controller', {
            init: function () {
                this.lastUpdate = 0;
                this.gripperState = false;
                this.lastGripperCheck = 0;

                // Reference pose (captured when entering VR or first frame)
                this.referenceY = null;
            },
            tick: function (time, timeDelta) {
                const now = Date.now();

                // Get world position and rotation
                const worldPos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(worldPos);

                const worldQuat = new THREE.Quaternion();
                this.el.object3D.getWorldQuaternion(worldQuat);

                // Convert quaternion to euler
                const euler = new THREE.Euler().setFromQuaternion(worldQuat, 'YXZ');

                // --- GRIP BUTTON (Button index 2 is squeeze/grip on Quest) ---
                let gripPressed = false;
                if (this.el.components['oculus-touch-controls']) {
                    const controller = this.el.components['oculus-touch-controls'].controller;
                    if (controller && controller.gamepad && controller.gamepad.buttons) {
                        // Try multiple button indices - Quest grip is usually 1 or 2
                        gripPressed = controller.gamepad.buttons[1]?.pressed ||
                            controller.gamepad.buttons[2]?.pressed || false;
                    }
                }

                // Toggle gripper on grip press
                if (gripPressed !== this.gripperState && (now - this.lastGripperCheck > 300)) {
                    this.gripperState = gripPressed;
                    if (gripPressed) {
                        // Only send on press, not release
                        fetch('/gripper', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ closed: true })
                        }).catch(e => console.error('Gripper error:', e));
                    } else {
                        fetch('/gripper', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ closed: false })
                        }).catch(e => console.error('Gripper error:', e));
                    }
                    this.lastGripperCheck = now;
                }

                // --- ARM KINEMATICS ---
                if (now - this.lastUpdate > UPDATE_INTERVAL) {

                    // Capture reference height on first frame
                    if (this.referenceY === null) {
                        this.referenceY = worldPos.y;
                    }

                    // Shoulder anchor (approximate right shoulder position)
                    const shoulderAnchor = { x: 0.2, y: 1.2, z: 0 };

                    const dx = worldPos.x - shoulderAnchor.x;
                    const dy = worldPos.y - shoulderAnchor.y;
                    const dz = worldPos.z - shoulderAnchor.z;

                    // Distance from shoulder (for elbow calculation)
                    const armLength = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    // --- SHOULDER PAN (Left/Right) ---
                    // X positive = right, X negative = left
                    // Robot: positive = right rotation
                    // NOT inverted: dx * 150
                    let s_pan = Math.max(-90, Math.min(90, dx * 150));

                    // --- SHOULDER LIFT (Up/Down) ---
                    // Y positive = up
                    // Robot: positive = up
                    // NOT inverted: dy * 120
                    let s_lift = Math.max(-60, Math.min(60, dy * 120));

                    // --- ELBOW FLEX (Reach/Bend) ---
                    // Use arm length: short distance = bent, long = straight
                    // Typical arm reach: 0.3m (close) to 0.7m (extended)
                    // Robot elbow: 0 = straight, negative = bent
                    // Remap: 0.3 -> -60, 0.7 -> 0
                    let e_flex = ((armLength - 0.3) / 0.4) * 60 - 60;
                    e_flex = Math.max(-90, Math.min(0, e_flex));

                    // --- WRIST ROLL (Controller Z-axis rotation) ---
                    // Reduced sensitivity: divide by 2
                    let w_roll = THREE.MathUtils.radToDeg(euler.z) * 0.5;
                    w_roll = Math.max(-150, Math.min(150, w_roll));

                    // --- WRIST FLEX (Controller X-axis rotation / pitch) ---
                    // Reduced sensitivity: divide by 2
                    let w_flex = THREE.MathUtils.radToDeg(euler.x) * 0.5;
                    w_flex = Math.max(-90, Math.min(90, w_flex));

                    const payload = {
                        positions: {
                            shoulder_pan: s_pan,
                            shoulder_lift: s_lift,
                            elbow_flex: e_flex,
                            wrist_roll: w_roll,
                            wrist_flex: w_flex
                        }
                    };

                    fetch('/arm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).catch(e => console.error('Arm error:', e));

                    this.lastUpdate = now;
                }
            }
        });

        // =============================================
        // 3. TEXTURE AUTO-REFRESH (for MJPEG stream)
        // =============================================
        AFRAME.registerComponent('auto-refresh-texture', {
            tick: function () {
                const mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material && mesh.material.map) {
                    mesh.material.map.needsUpdate = true;
                }
            }
        });

    </script>
</body>

</html>